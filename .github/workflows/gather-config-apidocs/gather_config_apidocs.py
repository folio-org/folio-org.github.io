#!/usr/bin/env python3

"""
Gather configuration files that have been generated by CI jobs api-doc from S3 of each relevant back-end module. Assemble complete config to be utilised by dev.f.o reference/api navigation facility.

   Returns:
       0: Success.
       1: One or more failures with processing.
       2: Configuration issues.
"""

# pylint: disable=C0413
import sys
if sys.version_info[0] < 3:
    raise RuntimeError("Python 3 or above is required.")

import argparse
import json
import logging
from operator import itemgetter
import os
import pprint
from time import sleep

import requests

SCRIPT_VERSION = "1.0.0"

LOGLEVELS = {
    "debug": logging.DEBUG,
    "info": logging.INFO,
    "warning": logging.WARNING,
    "error": logging.ERROR,
    "critical": logging.CRITICAL
}
PROG_NAME = os.path.basename(sys.argv[0])
PROG_DESC = __import__('__main__').__doc__
LOG_FORMAT = "%(levelname)s: %(name)s: %(message)s"
LOGGER = logging.getLogger(PROG_NAME)

def get_options():
    """Gets the command-line options."""
    parser = argparse.ArgumentParser(description=PROG_DESC)
    parser.add_argument(
        "-l", "--loglevel",
        choices=["debug", "info", "warning", "error", "critical"],
        default="info",
        help="Logging level. (Default: %(default)s)"
    )
    parser.add_argument(
        "-t", "--test", action="store_true",
        help="Test mode. Consider a few specific modules. (Default: False)"
    )
    args = parser.parse_args()
    logging.basicConfig(format=LOG_FORMAT)
    loglevel = LOGLEVELS.get(args.loglevel.lower(), logging.NOTSET)
    LOGGER.setLevel(loglevel)
    # Display a version string
    LOGGER.info("Using version: %s", SCRIPT_VERSION)
    url_base_devweb = "https://raw.githubusercontent.com/folio-org/folio-org.github.io/master/_data"
    url_repos = os.path.join(url_base_devweb, "repos.json")
    status, json_repos = get_json_contents(url_repos)
    if not status:
        sys.exit(2)
    if args.test:
        LOGGER.info("TEST mode.")
        delay = 0
        list_modules_test = ["mod-notes", "mod-search", "mod-quick-marc"]
    else:
        delay = 3
        list_modules_test = []
    return json_repos, list_modules_test, delay

def get_json_contents(url):
    """Gets the JSON contents from the specified url."""
    status = True
    contents = ""
    try:
        http_response = requests.get(url)
        http_response.raise_for_status()
    except requests.exceptions.HTTPError as err:
        LOGGER.critical("HTTP error retrieving file: %s", err)
        status = False
    except Exception as err:
        LOGGER.critical("Error retrieving file: %s", err)
        status = False
    else:
        try:
            contents = json.loads(http_response.text)
        except Exception as err:
            LOGGER.critical("Trouble loading JSON: %s", err)
            status = False
    return status, contents

def store_config(output_json):
    """Store this JSON output."""
    output_dir = "IG-data"
    os.makedirs(output_dir, exist_ok=True)
    output_pn = os.path.join(output_dir, "config-apidocs.json")
    with open(output_pn, "w") as output_fh:
        output_fh.write(json.dumps(output_json, sort_keys=True, indent=2, separators=(",", ": ")))
        output_fh.write("\n")

def list_api_modules(json_repos):
    """Produce a list of API-using modules."""
    list_modules = []
    for mod in sorted(json_repos["repos"], key=itemgetter('name')):
        try:
            isApi = mod["ramlDirName"]
        except KeyError:
            continue
        else:
            list_modules.append(mod["name"])
            continue
        try:
            isApi = mod["hintOas"]
        except KeyError:
            continue
        else:
            list_modules.append(mod["name"])
            continue
    LOGGER.debug("Found %s repos", len(list_modules))
    return list_modules

def inspect_s3(mod_name):
    """Inspect the S3 space of this module."""
    LOGGER.debug("Inspecting S3 %s", mod_name)
    url_base = "https://s3.amazonaws.com/foliodocs/api/{}".format(mod_name)
    items_upload = []
    json_config = {}
    url_upload = url_base + "/u/files-upload.txt"
    url_config = url_base + "/config-doc.json"
    try:
        http_response = requests.get(url_upload)
        http_response.raise_for_status()
    except requests.exceptions.HTTPError as err:
        pass
    except Exception as err:
        LOGGER.critical("%s: Error retrieving text data file: %s", mod_name, err)
    else:
        items_upload = http_response.text.rstrip().split("\n")
    try:
        http_response = requests.get(url_config)
        http_response.raise_for_status()
    except requests.exceptions.HTTPError as err:
        pass
    except Exception as err:
        LOGGER.critical("%s: Error retrieving JSON data file: %s", mod_name, err)
    else:
        try:
            json_config = json.loads(http_response.text)
        except Exception as err:
            LOGGER.error("%s: Trouble loading JSON: %s", mod_name, err)
    return items_upload, json_config

def main():
    exit_code = 0
    json_apidocs = {}
    (json_repos, list_modules_test, delay) = get_options()
    list_modules = list_api_modules(json_repos)
    if list_modules_test:
        list_modules = list_modules_test
    for mod_name in list_modules:
        (items_upload, json_config) = inspect_s3(mod_name)
        if items_upload:
            LOGGER.info("%s: Found files-upload: %s", mod_name, items_upload)
        if json_config:
            LOGGER.info("%s: Found config-doc.json", mod_name)
        sleep(delay)
    store_config(json_apidocs)
    logging.shutdown()
    return exit_code

if __name__ == "__main__":
    sys.exit(main())
