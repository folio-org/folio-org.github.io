---
layout: null
---

# Porting your module from mod-configuration to mod-settings

<!-- md2toc -l 2 porting-guide.md -->
* [Introduction](#introduction)
* [Changes to be made to the module](#changes-to-be-made-to-the-module)
    * [1. Change the interface specification](#1-change-the-interface-specification)
    * [2. Choose configuration scope or scopes](#2-choose-configuration-scope-or-scopes)
    * [3. Define permissions](#3-define-permissions)
    * [4. Change the WSAPI path](#4-change-the-wsapi-path)
    * [5. Change the entry parameters](#5-change-the-entry-parameters)
    * [6. Consider how to port existing configuration entries](#6-consider-how-to-port-existing-configuration-entries)
* [Appendix A. The example of ui-ldp](#appendix-a-the-example-of-ui-ldp)
* [Appendix B. Cross-cutting uses of mod-configuration](#appendix-b-cross-cutting-uses-of-mod-configuration)
* [Appendix C. Towards deprecating mod-configuration](#appendix-c-towards-deprecating-mod-configuration)



## Introduction

[As described in detail elsewhere](https://github.com/MikeTaylor/folio-docs/blob/main/doc/fixing-mod-configuration.md), FOLIO's configuration-store module, [mod-configuration](https://github.com/folio-org/mod-configuration/), suffers from a catastrophic security hole: a single set of permissions govern access to all configuration entries, so that -- for example -- a user with permission to read the controlled vocabulary of bulk-edit statuses also has permission to read the LDP database connection details.

Rather than trying to make changes to mod-configuration to fix this -- changes which would necessarily be backwards-incompatible -- it was decided to implement the necessary API changes in a new module instead, [mod-settings](https://github.com/folio-org/mod-settings/). This decision allows us to avoid continuing to maintain old code that was written using [the outdated RMB framework](https://github.com/folio-org/raml-module-builder), and results in a smaller, cleaner code-base.

In order to benefit from the security fix that mod-settings provides, client code (whether UI modules or backend modules) need make several simple changes. The bulk of this document outlines what these changes are.



## Changes to be made to the module

Both backend modules and UI modules can use the configuration store. Both kinds of modules will need to be upgraded.


### 1. Change the interface specification

FOLIO modules declare which interfaces they consume. This information is used in dependency resolution and for other purposes. Such information is held in the module descriptor.

**For backend modules.**
In the module descriptor  -- often `descriptors/ModuleDescriptor-template.json` -- edit the `"requires"` section to remove the `configuration` interface's entry (usually something like `{ "id": "configuration", "version": "2.0" }`). Replace it with an entry for the new `settings` interface: `{ "id": "settings", "version": "1.0" }`.

**For UI modules.**
The module descriptor is autogenerated from the package file `package.json`, so it is this file that must be edited. In the `"stripes"` section, edit the `"okapiInterfaces"` subsection to remove (for example) `"configuration": "2.0"` and replace it with `"settings": "1.0"`.


### 2. Choose configuration scope or scopes

In mod-configuration, access to all entries is governed by a single set of permissions. By contrast, in mod-settings, each module defines one or more scopes, each of which is governed by its own permissions.

In migrating to mod-settings, it is necessary to decide what scope or scopes to use. To avoid multiple modules independently choosing the same scopes, it is recommended to choose scope names beginning with the name of the module (e.g. `ui-ldp` or `mod-oai-pmh`). A module that needs only a single scope can use the module name alone; a module that needs multiple scopes can build them using dot-separated components. For example, LDP app might define `ui-ldp.admin` and `ui-ldp.queries` scopes -- for administrative configuration such as database-connection details, and the ability to load/save queries, respectively.


### 3. Define permissions

`mod-settings` does not itself define the permissions associated with any scope -- only its own scope-independent permissions. For each scope used by a client module, then, that module must define up to six permissions (depending on which operations are to be supported). These permissions' named must begin with `mod-settings` followed by one of the access-types (`global`, `owner`, `user`), and the name of the scope.

Using the scope `foobar` as our example, these could be:
* `mod-settings.global.read.foobar` -- read global (tenant-wide) settings
* `mod-settings.global.write.foobar` -- create, update and delete global (tenant-wide) settings
* `mod-settings.owner.read.foobar` -- the user may read his or her own settings
* `mod-settings.owner.write.foobar` -- the user may create, update and delete his or her own settings
* `mod-settings.users.read.foobar` -- read _any_ user's settings
* `mod-settings.users.write.foobar` -- create, update and delete _any_ user's settings

Modules _may_, but need not, also define higher-level permissions for assignment to users. For example, the `MODULE.settings.regular-user` permission might include `mod-settings.global.read.foobar`, `mod-settings.owner.read.foobar` and `mod-settings.owner.write.foobar`, allowing users with this permission to read tenant-wide settings provided by an administrator, and maintain their own personal overrides.


### 4. Change the WSAPI path

The old mod-configuration web-service is accessed on the WSAPI path `/configurations/entries`. This will need to be changed to `/settings/entries`.

**Note.**
The change to the path must not be made in isolation, but in conjunction with the changes to the entry parameters documented below, since the mod-settings API is not identical to that of mod-configuration.


### 5. Change the entry parameters

Some thought must be given to how to represent locator information from mod-configuration in mod-settings, bearing in mind that the labelling choices used in those two systems are necessarily different. The former locates entries by a compound key consisting of a [`module`, `configName`, `code`] triplet: it is not in general possible to blindly map from this to a [`scope`, `key`] pair. So recasting locators from the old the new representation will involve module-specific domain knowledge.

**Example 1.**
The Users UI modules currently stores in mod-configuration a list of the IDs of users whose records may not be edited (usually just that of the tenant administrator). This entry is identified by the module name `@folio/users` and the configName `suppressEdit`, with no code. This translates simply to a mod-settings entry with scope `ui-users` and key `suppressEdit` (using the canonical module name as the scope).

**Example 2.**
The backend email-sending module mod-email stores SMTP connection information in several mod-configuration entries, all with module name `SMTP_SERVER` and configName `email`, and with codes such as `EMAIL_SMTP_HOST`, `EMAIL_SMTP_PORT`, `EMAIL_FROM`, etc. This information would be naturally represented as a group of mod-settings entries, all with scope `mod-email` and keys `smtpHost`, `smtpPort`, `from`, etc.

**Example 3.**
Consider a backend module, `mod-animals`, which uses mod-configuration to store three settings:
* `moduleName`=`ANIMALS`, `configName`=`dog`
* `moduleName`=`ANIMALS`, `configName`=`cat`, `code`=`lion`
* `moduleName`=`ANIMALS`, `configName`=`cat`, `code`=`tiger`

In example 1 above, `configName` was used and `code` was not; in example 2, `configName` was the same for all entries and `code` was used. So in both cases it was simple to determine what information to put in the mod-settings `key`. In this case, the `configName` and `code` (when supplied) need to be merged into the `key` with a dot separating the facets:
* `scope`=`mod-animals`, `key`=`dog`
* `scope`=`mod-animals`, `key`=`cat.lion`
* `scope`=`mod-animals`, `key`=`cat.tiger`

**Note.**
Since many uses of configuration on UI modules are made via utility components such as [`<ConfigManager>`](https://github.com/folio-org/stripes-smart-components/tree/master/lib/ConfigManager), changes to the WSAPI path and entry parameters may need to be done by updating library components.


### 6. Consider how to port existing configuration entries

It is one thing to update code to use mod-settings instead of mod-configuration; but it is another to ensure that the relevant entries are in place to keep things working as they were before. As noted above, it is not in general possible to automatically translate mod-configuration entry parameters to those used by mod-settings, so module-specific logic will be necessary.

It may be worthwhile to create a configurable entry-porting tool.



## Appendix A. The example of ui-ldp

To make the above more concrete, here are the steps taken to use mod-settings by the LDP app.

* The package file defines [four permissions](https://github.com/folio-org/ui-ldp/blob/1e3cdaa2fd0582ab3116499978d6f331a18e97ba/package.json#L176-L195): read and write for each of two scopes, which are named `ui-ldp.admin` (for setting things like the default number of records requested) and `ui-ldp.queries` (for loading and saving queries).
* The settings page that maintains record-limits does so by invoking `<ConfigManager>` with `scope="ui-ldp.admin"` and `configName="config"` â€” [the invocation](https://github.com/folio-org/ui-ldp/blob/1e3cdaa2fd0582ab3116499978d6f331a18e97ba/src/settings/RecordLimits.js#L47-L54) works because that component has been extended to work with mod-settings as well as mod-configuration.
* Those settings [are loaded](https://github.com/folio-org/ui-ldp/blob/1e3cdaa2fd0582ab3116499978d6f331a18e97ba/src/util/loadConfig.js#L21-L22) by fetching `/settings/entries?query=(scope=="ui-ldp.admin" and key=="config")`.
* A query [is saved](https://github.com/folio-org/ui-ldp/blob/1e3cdaa2fd0582ab3116499978d6f331a18e97ba/src/components/QueryBuilder/SaveQueryModal.js#L39-L47) by POSTing (for a new query) or PUTting (to overwrite an existing one) to `/settings/entries` a settings record that has `scope: 'ui-ldp.queries'`}.
* Saved queries [are loaded](https://github.com/folio-org/ui-ldp/blob/1e3cdaa2fd0582ab3116499978d6f331a18e97ba/src/components/SavedQueries/SavedQueries.js#L17-L20) by fetching `/settings/entries?query=scope=="ui-ldp.queries"`



## Appendix B. Cross-cutting uses of mod-configuration

A brief investigation of client-side utilities shows that data from mod-configuration is used in at least two places:
* [Tags](https://github.com/folio-org/stripes-smart-components/tree/master/lib/Tags) are enabled or disabled [according to a mod-configuration setting](https://github.com/folio-org/stripes-smart-components/blob/b610b3b04c7db137489e59b9de18a30ea41dd821/lib/Tags/withTags.js#L11).
* [Custom Fields](https://github.com/folio-org/stripes-smart-components/tree/master/lib/CustomFields) are heavily dependent on mod-configuration.

In due time, we will want to update both of these to use mod-settings.



## Appendix C. Towards deprecating mod-configuration

This document explains _how_ to port a FOLIO module from mod-configuration to mod-settings, but we also need to consider the broader issues of _whether_ and _when_ to do so.

mod-settings and mod-configuration can and do happily co-exist, as they implement different interfaces with different WSAPI paths. In principle a single module could use both -- for example, to provide a way of copying entries from mod-configuration to mod-settings.

The addition of mod-settings to FOLIO, then, does not require any immediate action on the part of modules that use mod-configuration. Such modules will continue working for the immediate future, as there are no plans to deprecate mod-configuration in the short term.

Once mod-settings is established, new modules should generally use mod-settings rather than mod-configuration. (And in most cases, rather than implementing their own configuration stores.)
**Note.**
This is not official Technical Council policy, just friendly advice.

At this time, it will become an option for maintainers of individual modules to migrate them -- hopefully painlessly -- away from mod-configuration, following the instructions in this guide. Maintainers of these modules will in most cases want to upgrade as soon as possible because of the gaping security hole in mod-configuration.

Policies and timelines about completing that migration for all FOLIO modules are a matter for the Technical Council. One approach would be pick a date, perhaps a year or two into the future, for deprecation of mod-configuration. Modules would be required to complete migration before that date. A less prescriptive approach would be to monitor how many modules still express a dependency on the old configuration interface, and when that number falls to a certain level, ask the maintainers of the holdouts to migrate by some specified sunset date.



